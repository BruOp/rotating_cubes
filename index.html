<!DOCTYPE html>
<html lang="en">
<head>
	<title>Rotating Cubes</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #ffffff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #ffffff;
		}

		#oldie a {
			color: #da0;
		}

		#notSupported {
			width: 50%;
			margin: auto;
			border: 2px red solid;
			margin-top: 20px;
			padding: 10px;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	
	<script src="vendor/three.min.js"></script>
	<script src="vendor/stats.min.js"></script>

	<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 offset;
		attribute vec2 uv;

		varying vec2 vUv;
    varying vec3 vPosition;

		void main() {

			vPosition = offset + position;
			
			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

		}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		precision highp float;

    uniform float width;
    uniform float height;

		varying vec2 vUv;
    varying vec3 vPosition;

		void main() {
      vec2 screenUV = vec2((vPosition.x + .5 * width) / width, (vPosition.y + .5 * height) / height);
			gl_FragColor = vec4( screenUV, 1., 1.);

		}

	</script>

	<script>
		var container, stats;

		var camera, scene, renderer;
		var orientations;


		function init() {
      var height = window.innerHeight;
      var width  = window.innerWidth;
      var ROW_COUNT = 20;
      var boxLengthInPixels = height / ROW_COUNT;
      var COLUMN_COUNT = Math.ceil(width / boxLengthInPixels);

			container = document.getElementById( 'container' );
      
			camera = new THREE.OrthographicCamera( -.5 * width, .5 * width, .5 * height, -.5 * height, 1, boxLengthInPixels * 4 );
			camera.position.z = boxLengthInPixels * 2;

			renderer = new THREE.WebGLRenderer();
			scene = new THREE.Scene();

			// geometry

			var instances = ROW_COUNT * COLUMN_COUNT;

			var geometry = new THREE.InstancedBufferGeometry();

			// per mesh data
			var vertices = new THREE.BufferAttribute( new Float32Array( [
				// Front
				-1, 1, 1,
				1, 1, 1,
				-1, -1, 1,
				1, -1, 1,
				// Back
				1, 1, -1,
				-1, 1, -1,
				1, -1, -1,
				-1, -1, -1,
				// Left
				-1, 1, -1,
				-1, 1, 1,
				-1, -1, -1,
				-1, -1, 1,
				// Right
				1, 1, 1,
				1, 1, -1,
				1, -1, 1,
				1, -1, -1,
				// Top
				-1, 1, 1,
				1, 1, 1,
				-1, 1, -1,
				1, 1, -1,
				// Bottom
				1, -1, 1,
				-1, -1, 1,
				1, -1, -1,
				-1, -1, -1
			].map(function(el) {
        return 0.5 * el * boxLengthInPixels;
      } ) ), 3 );

			geometry.addAttribute( 'position', vertices );

			var uvs = new THREE.BufferAttribute( new Float32Array( [
						//x	y	z
						// Front
						0, 0,
						1, 0,
						0, 1,
						1, 1,
						// Back
						1, 0,
						0, 0,
						1, 1,
						0, 1,
						// Left
						1, 1,
						1, 0,
						0, 1,
						0, 0,
						// Right
						1, 0,
						1, 1,
						0, 0,
						0, 1,
						// Top
						0, 0,
						1, 0,
						0, 1,
						1, 1,
						// Bottom
						1, 0,
						0, 0,
						1, 1,
						0, 1
			] ), 2 );

			geometry.addAttribute( 'uv', uvs );

			var indices = new Uint16Array( [
				0, 1, 2,
				2, 1, 3,
				4, 5, 6,
				6, 5, 7,
				8, 9, 10,
				10, 9, 11,
				12, 13, 14,
				14, 13, 15,
				16, 17, 18,
				18, 17, 19,
				20, 21, 22,
				22, 21, 23
			] );

			geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );

			// per instance data
			var offsets = new THREE.InstancedBufferAttribute( new Float32Array( instances * 3 ), 3, 1 );
      var dx = (boxLengthInPixels / width);
      var dy = 1 / ROW_COUNT;
			for ( var i = 0, ul = offsets.count; i < ul; i++ ) {
        columnIndex = (i % COLUMN_COUNT)
        rowIndex    = Math.floor(i / COLUMN_COUNT)
        //If we have an odd number of rows/columns
				var x = width  * (dx * (columnIndex - .5 * COLUMN_COUNT + 0.5));
				var y = height * (dy * (rowIndex - .5 * ROW_COUNT + 0.5));
				// move out at least 5 units from center in current direction
				offsets.setXYZ( i, x, y, 0 );
			}

			geometry.addAttribute( 'offset', offsets ); // per mesh translation

			// material
			var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
			texture.anisotropy = renderer.getMaxAnisotropy();

			var material = new THREE.RawShaderMaterial( {

				uniforms: {
          width: { type: "f", value: width },
          height: { type: "f", value: height }
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				side: THREE.DoubleSide,
				transparent: false

			} );

			var mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );


			if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === false ) {
				document.getElementById( "notSupported" ).style.display = "";
				return;
			}

			renderer.setClearColor( 0x101010 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			stats = new Stats();
			container.appendChild( stats.dom );

			window.addEventListener( 'resize', onWindowResize, false );

		}

		function onWindowResize( event ) {
      
			camera.left  = -.5 * window.innerWidth;
      camera.right = .5 * window.innerWidth;
      camera.top = .5 * window.innerHeight;
      camera.bottom = -.5 * window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//

		function animate() {

			requestAnimationFrame( animate );

			render();
			stats.update();

		}

		var lastTime = 0;

		var moveQ = ( new THREE.Quaternion( .5, .5, .5, 0.0 ) ).normalize();
		var tmpQ = new THREE.Quaternion();
		var currentQ = new THREE.Quaternion();
		function render() {

			var time = performance.now();

			var object = scene.children[0];

			renderer.render( scene, camera );
      
			lastTime = time;
		}

		init();
		animate();
	</script>

</body>



</html>
