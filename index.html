<!DOCTYPE html>
<html lang="en">
<head>
	<title>Rotating Cubes</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #ffffff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #ffffff;
		}

		#oldie a {
			color: #da0;
		}

		#notSupported {
			width: 50%;
			margin: auto;
			border: 2px red solid;
			margin-top: 20px;
			padding: 10px;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	
	<script src="vendor/three.min.js"></script>
	<script src="vendor/stats.min.js"></script>
  <script src="js/BoxGrid.js"></script>
	<script id="vertexShader" type="x-shader/x-vertex">
    #define M_PI 3.1415926535897932384626433832795
    #define MAX_HYPOTENUESE 0.70710678118
		precision highp float;

    uniform float width;
    uniform float height;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;
    
    uniform sampler2D rotationField;
    uniform float time;
    
		attribute vec3 position;
    attribute vec3 normal;
		attribute vec3 offset;
		attribute vec2 uv;

    varying vec3 vNormal;
    varying vec2 vUv;
    
		vec2 getScreenUV(vec3 offset) {
      return vec2(
        (offset.x + .5 * width) / width,
        (offset.y + .5 * height) / height
      );
    }
    
    vec2 convertToRadians(vec2 rotations) {
      // We expect 'rotation' to be normalized from 0 to 1.
      return 2. * M_PI * (rotations - vec2(.5, .5));
    }
    
    mat4 constructTransformationMatrix(vec2 angles, vec3 offset) {
      mat4 rotationMatrix;
      //The index here refers to the COLUMNS of the matrix
      rotationMatrix[0] = vec4(
        cos(angles.y),
        0,
        -sin(angles.y),
        0
      );
      rotationMatrix[1] = vec4(
        sin(angles.x) * sin(angles.y),
        cos(angles.x),
        sin(angles.x) * cos(angles.y),
        0
      );
      rotationMatrix[2] = vec4(
        cos(angles.x) * sin(angles.y),
        -sin(angles.x),
        cos(angles.x) * cos(angles.y),
        0
      );
      rotationMatrix[3] = vec4(offset, 1);
      
      return rotationMatrix;
    }
    
    void main() {
      vUv = uv;
      vNormal = normal;
      
      vec2 screenUV = getScreenUV(offset);
      // We sample our rotation field by the cubes position from origin;
      vec2 angles = convertToRadians(sin(time) * texture2D(rotationField, screenUV).rg);
      mat4 rotationMatrix = constructTransformationMatrix(angles, offset);
      
			gl_Position = projectionMatrix * modelViewMatrix * rotationMatrix * vec4(position, 1.);

		}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		precision highp float;

    uniform float width;
    uniform float height;
    uniform sampler2D map;

    varying vec3 vNormal;
    varying vec2 vUv;
    
    float uFromNormal(vec3 normal) {
      return 0.25 * (normal.x + 1.) + 0.75 * floor(-(normal.z - 2.) / 3.);
    }
    
    float vFromNormal(vec3 normal) {
      return (normal.y - 1.) / -3.;
    }
    
    vec2 calculateUV(vec3 normal, vec2 uv) {
      vec2 normUV = vec2(uFromNormal(normal), vFromNormal(normal));
      return normUV + vec2(.25 * uv.x, .33333333 * uv.y);
    }

		void main() {
      
      vec2 uv = calculateUV(vNormal, vUv);
      gl_FragColor = texture2D(map, uv);
		}

	</script>

  <script src="js/app.js"></script> 

</body>



</html>
